package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"github.com/xorwise/ozon-todo/graph/model"
)

// Author is the resolver for the author field.
func (r *commentResolver) Author(ctx context.Context, obj *model.Comment) (*model.User, error) {
	rows := r.DB.QueryRowContext(ctx, `SELECT id, username FROM users where id = $1`, obj.AuthorID)

	var u model.User
	err := rows.Scan(&u.ID, &u.Username)
	return &u, err
}

// AddPost is the resolver for the addPost field.
func (r *mutationResolver) AddPost(ctx context.Context, input model.AddPostInput) (*model.Post, error) {
	newPost := &model.Post{
		Title:    input.Title,
		Content:  input.Content,
		AuthorID: input.AuthorID,
	}

	rows, err := r.DB.ExecContext(
		ctx, `INSERT INTO posts (title, content, author_id, comments_allowed) 
			VALUES ($1, $2, $3, $4)`,
		newPost.Title,
		newPost.Content,
		input.AuthorID,
		true,
	)

	if err != nil {
		return &model.Post{}, err
	}

	insertedId, err := rows.LastInsertId()
	newPost.ID = int(insertedId)
	return newPost, nil
}

// AddComment is the resolver for the addComment field.
func (r *mutationResolver) AddComment(ctx context.Context, input model.AddCommentInput) (*model.Comment, error) {
	newComment := &model.Comment{
		PostID:    input.PostID,
		ParentID:  input.ParentID,
		AuthorID:  input.AuthorID,
		Content:   input.Content,
		CreatedAt: time.Now(),
	}

	rows, err := r.DB.ExecContext(
		ctx,
		`INSERT INTO comments (post_id, parent_id, author_id, content, created_at)
		VALUES ($1, $2, $3, $4, $5)`,
		newComment.PostID,
		newComment.ParentID,
		input.AuthorID,
		newComment.Content,
		newComment.CreatedAt.Unix(),
	)

	if err != nil {
		return &model.Comment{}, err
	}

	insertedId, err := rows.LastInsertId()
	newComment.ID = int(insertedId)
	return newComment, nil
}

// ToggleComments is the resolver for the toggleComments field.
func (r *mutationResolver) ToggleComments(ctx context.Context, postID string, allow bool) (*model.Post, error) {
	userID := ctx.Value("userID").(string)
	var post model.Post

	err := r.DB.QueryRowContext(ctx, `SELECT id, title, content, author_id, comments_allowed FROM posts where id = $1`, postID).Scan(
		&post.ID,
		&post.Title,
		&post.Content,
		&post.AuthorID,
		&post.CommentsAllowed,
	)
	if err != nil {
		return &model.Post{}, err
	}
	id, err := strconv.Atoi(userID)
	if err != nil {
		return &model.Post{}, err
	}
	if post.AuthorID != id {
		return &model.Post{}, fmt.Errorf("forbidden")
	}
	post.CommentsAllowed = allow
	return &post, nil
}

// Author is the resolver for the author field.
func (r *postResolver) Author(ctx context.Context, obj *model.Post) (*model.User, error) {
	rows := r.DB.QueryRowContext(ctx, `SELECT id, username FROM users where id = $1`, obj.AuthorID)

	var u model.User
	err := rows.Scan(&u.ID, &u.Username)
	return &u, err
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context, limit *int, offset *int) ([]*model.Post, error) {
	panic(fmt.Errorf("not implemented: Posts - posts"))
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	panic(fmt.Errorf("not implemented: Post - post"))
}

// Comments is the resolver for the comments field.
func (r *queryResolver) Comments(ctx context.Context, postID string, limit *int, offset *int) ([]*model.Comment, error) {
	panic(fmt.Errorf("not implemented: Comments - comments"))
}

// CommentAdded is the resolver for the commentAdded field.
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID string) (<-chan *model.Comment, error) {
	panic(fmt.Errorf("not implemented: CommentAdded - commentAdded"))
}

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Post returns PostResolver implementation.
func (r *Resolver) Post() PostResolver { return &postResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type commentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type postResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
